//hyperbole model

var approx = function(x,b) {
  var b = 10
  return b * Math.round(x / b)
}

// Prior probability of kettle prices (taken from human experiments)

var beta = 4

var oldpricePrior = function() {
  return categorical({
    vs: [
      50, 51,
      500, 501,
      1000, 1001,
      5000, 5001,
      10000, 10001
    ],
    ps: [
      0.4205, 0.3865,
      0.0533, 0.0538,
      0.0223, 0.0211,
      0.0112, 0.0111,
      0.0083, 0.0120
    ]
  }) 
}

// new pricePrior ^beta
var pricePrior = function () {
   return Math.pow(oldpricePrior(), beta)
}

// Probability that given a price state, the speaker thinks it's too
// expensive (taken from human experiments)
var valencePrior = function(state) {
  var probs = {
    50 : 0.3173,
    51 : 0.3173,
    500 : 0.7920,
    501 : 0.7920,
    1000 : 0.8933,
    1001 : 0.8933,
    5000 : 0.9524,
    5001 : 0.9524,
    10000 : 0.9864,
    10001 : 0.9864
  }
  var tf = flip(probs[state])
  return tf
}



var qudFns = {
  price : function(state) {return { price: state.price } },
  valence : function(state) {return { valence: state.valence } },
  priceValence : function(state) {
    return { price: state.price, valence: state.valence }
  },
  approxPrice : function(state) {return { price: approx(state.price) } },
  approxPriceValence: function(state) {
    return { price: approx(state.price), valence: state.valence  }
  }
}

// Literal interpretation "meaning" function;
// checks if uttered number reflects price state
var meaning = function(utterance, price) {
  return utterance == price
}

//set parameter n "express emotions"
var n = 1

// Prior over QUDs
var qudPrior = function(valence) {
  if (valence == true)  {categorical({
    vs: ["price", "valence", "priceValence", "approxPrice", "approxPriceValence"],
    ps: [1, n, n, 1, n]
  })}
else  {categorical({
    vs: ["price", "valence", "priceValence", "approxPrice", "approxPriceValence"],
    ps: [n, 1, 1, n, 1]
  })}
}

// Define list of possible utterances (same as price states)
var utterances = [
  50, 51,
  500, 501,
  1000, 1001,
  5000, 5001,
  10000, 10001
]

// precise numbers can be assumed to be costlier than round numbers
var preciseNumberCost = 1
var utteranceCost = function(numberUtt){
  return numberUtt == approx(numberUtt) ? // if it's a round number utterance
        0 : // no cost
        preciseNumberCost // cost of precise numbers (>= 0)
}

// set speaker optimality
var alpha = 10

var utteranceProbs = map(function(numberUtt){
  return Math.exp(- alpha * utteranceCost(numberUtt))}, utterances)

var utterancePrior = function() {
  categorical({ vs: utterances, ps: utteranceProbs })

}

// Literal listener, infers the qud value assuming the utterance is
// true of the state
var literalListener = cache(function(utterance, qud) {
  return Infer({model: function(){
    var price = pricePrior() // uncertainty about the price
    var valence = valencePrior(price) // uncertainty about the valence
    var fullState = {price, valence}
    condition( meaning(utterance, price) )
    var qudFn = qudFns[qud]
    return qudFn(fullState)
  }
})})

// Speaker, chooses an utterance to convey a particular value of the qud
var speaker = cache(function(qudValue, qud) {
  return Infer({model: function(){
    var utterance = utterancePrior()
    factor(alpha*literalListener(utterance,qud).score(qudValue))
    return utterance
  }
})})

// Pragmatic listener, jointly infers the price state, speaker valence, and QUD
var pragmaticListener = cache(function(utterance) {
  return Infer({model: function(){
    //////// priors ////////
    var price = pricePrior()
    var valence = valencePrior(price)
    var qud = qudPrior(valence)
    ////////////////////////
    var fullState = {price, valence}
    var qudFn = qudFns[qud]
    var qudValue = qudFn(fullState)
    observe(speaker(qudValue, qud), utterance)
    return fullState
  }
})})

var listenerPosterior = pragmaticListener(10000)

print("pragmatic listener's joint interpretation of 'The kettle cost $10,000':")
viz(listenerPosterior)

// print("marginal distributions:")
viz(marginalize(listenerPosterior, "price"))
viz(marginalize(listenerPosterior, "valence"))
